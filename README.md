# STM32_GPIO
The previous version of my GPIObase class approached interrupt handling and GPIO configuration differently. It relied on a static list to store callback references for each GPIO pin.

(Insert image)
(Insert image)

![image](https://github.com/user-attachments/assets/1de6a56d-1cda-4771-93ff-fb419be9082e)

![image](https://github.com/user-attachments/assets/eb970915-6ccf-4938-8dcf-adeee92ac977)

The init() function of the GPIO objects was essentially empty, as GPIO initialization was typically performed by the MX_GPIO_Init() function, which is auto-generated by STM32CubeMX during project setup.

# üÜï New approach:

The updated GPIObase class (v2.0) eliminates internal callback tracking altogether. Instead, you now handle GPIO interrupts directly in the global interrupt service routines. The motivation for this change was to simplify the structure and remove unnecessary overhead ‚Äî the previous version introduced a lot of boilerplate code with limited practical benefit, such as:

- A generic ISR handler class (ISRbase.h) to store GPIO objects and their callback routines in a static list:
ISRbase< Din >::ISR_LIST

- Searching for the appropriate callback function when an interrupt was triggered

- Maintaining and synchronizing the callback list

- And more...

![image](https://github.com/user-attachments/assets/ee47a4dd-e967-464c-8ae0-5a5c83491ee7)

With the new version, you can define as many custom GPIO child classes as you need ‚Äî each with preconfigured settings ‚Äî eliminating the need for CubeMX-generated GPIO configurations entirely for your user-defined pins.

# ‚öôÔ∏è Simplified Configuration without STM32CubeMX

For example, creating a digital input with falling edge detection and an internal pull-up resistor is straightforward:
![image](https://github.com/user-attachments/assets/f78acf83-a7e6-42a9-a5ac-2900e0f1428b)


The init() function now directly calls HAL_GPIO_Init(_Port, &_GPIOx); using the parameters provided in the constructor, ensuring full control over pin configuration.

# ‚úçÔ∏è Usage Example

GPIO object definition and usage are now more intuitive and modular:

![image](https://github.com/user-attachments/assets/535032b2-27b4-4348-a60c-9873643d549e)

![image](https://github.com/user-attachments/assets/f4fb55df-636a-4e63-b5b4-052ea0c84e90)

# üõ†Ô∏è Build System Update
In previous versions, the entire build and configuration process was managed via STM32CubeIDE. While that approach worked reasonably well, migrating to CMake has proven to be far more efficient and flexible.

The previous version of the GPIObase class can still be found here:
https://github.com/czagaadam/STM32CPP/tree/main/CPPLib/GPIObase

Feel free to choose which approach is more suitable for you!
